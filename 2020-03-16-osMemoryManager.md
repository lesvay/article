---
title: 存储器（内存）管理
date: 2020-03-16 11:14:20
categories: 
    - 操作系统
tags: 
    - memoryManager
---

# 内存管理概念

用来对内存进行分配保护和扩充

功能：内存分配与回收、地址变换、内存保护、内存扩充

过程：编译->链接->装入

- 静态链接：在程序运行前，先把各个目标模块及所需库链接成一个完整的可执行程序，以后不再拆开
- 装入时动态链接：边装入边链接
- 运行时动态链接：边运行边链接
- 绝对装入：在装入时就知道物理地址
- 可重定位装入：地址变换通常在装入时一次完成
- 动态运行装入：允许程序运行时在内存中移动位置，物理地址=基址寄存器+逻辑地址（逻辑地址是偏移地址，物理地址是内存中的地址）

内存保护：防止一个作业有意无意破坏操作系统或其他作业

| 内存保护方法                                         | 解释                                                   |
| ---------------------------------------------------- | ------------------------------------------------------ |
| 上下界寄存器方法                                     | 采用上下界分别存放作业结束地址和开始地址               |
| 基址（重定位寄存器）和限长寄存器（界地址寄存器）方法 | 限长寄存器与相对地址进行比较，超过则发生中断           |
| 存储保护键方法                                       | 给每个存储块分配一个单独的保护键，比较钥匙和锁是否匹配 |

# 交换与覆盖

| 技术     | 解释                           |
| -------- | ------------------------------ |
| 覆盖技术 | 解决程序不能全部装入内存中     |
| 交换技术 | 把暂时不用的程序或数据移入外存 |

# 分配管理方式

## 连续分配管理方式

### 单一连续分配

- 将内存分为两个连续存储区域，一个给操作系统，一个给用户
- 采用静态分配，适合单道程序

### 固定分区分配

- 每个分区可以装入一道程序，分区大小事先固定
- 缺乏灵活性，以产生碎片

### 动态分区分配

| 分区分配中的数据结构 | 解释                       |
| -------------------- | -------------------------- |
| 空闲分区表           | 每个空闲分区表对应一个表项 |
| 空闲分区链           | 指向下一个 空闲分区的指针  |

- 空闲分区表：每个空闲分区表对应一个表项
- 空闲分区链：指向下一个 空闲分区的指针

| 分区分配中的算法 | 解释                                         | 优点                                 | 缺点                                           |
| ---------------- | -------------------------------------------- | ------------------------------------ | ---------------------------------------------- |
| 首次适应算法FF   | 按地址来，每次都从队头开始                   | 保留了高位地址大的空闲区，无内部碎片 | 地位地址被划分，产生很多小的空闲区，无外部碎片 |
| 下次适应算法NF   | 按地址，循环，从上次空闲区下一个区开始       | 使空闲分区分布更加均匀               | 导致缺乏大的空闲分区                           |
| 最佳适应算法BF   | 按容量大小从大开始，找到一个可以满足的最小区 | 总能分到最恰当的分区，并保留最大的   | 产生很多碎片                                   |
| 最差适应算法WF   | 按容量大小从小开始，找到按要求最大的         | 使分给作业后剩的空闲分区比较大       | 无法满足大作业的申请                           |

分区回收：合并上面，合并下面，合并上下

| 分区分配的动态管理     | 解释                                   |
| ---------------------- | -------------------------------------- |
| 拼接技术               | 把已分配的移动到一端，碎片集中到一起   |
| 动态重定位分区分配技术 | 与上面的分配算法相同，并增加了拼接技术 |

## 非连续分配管理方式

### 基本分页管理方式

- 页：用户作业地址空间被划分成若干大小相同区域，成为页或页面
- 页表：将页面与物理地址一一对应形成一张表

![图片-基本分页管理方式](jibenfenyeguanli.png)

- 两级页表和多级页表
  - 页表大小计算
  - 两级页表：外层页号，外层内页地址，页内地址
  - 多级页表：增加级数，减小页表的大小
- 页的保护与共享
  - 地址越界保护：用地址和长度来保护信息安全
  - 访问控制信息保护
- 有效访问时间计算
  - 没有快表EAT=2t（t访存一次消耗时间）
  - 有快表EAT=a*b+(t+a)*(1-b)+t，（a访问快表时间，b快表命中率）
- 优点：利用率高，实现了离散分配，便于存储访问控制，无外部碎片
- 缺点：硬件支持，内存访问效率下降，共享困难，内部碎片

### 基本分段管理方式

- 段：一组逻辑意义上相对完整的信息集合，逻辑地址结构由段号和段内位移组成
- 段表及地址变换：
  - 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。
  - 比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。
  - 段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量>=C，则产生越界中断，否则继续执行。
  - 取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。
- 段的共享与保护：与页相同
- 优点：便于模块化、程序化处理数据结构，便于动态链接和共享、无内部碎片，方便编程、信息共享、信息保护
- 缺点：需要硬件支持、为满足动态增长减少外部碎片需要拼接技术、分段最大尺寸受主存可用空间限制、有外部碎片

- 段与页区别

  ![图片-段页的区别](duanyequbie.jpg)

- 基本段页式管理方式

  页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。

  在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位

  结合了两者的优点，但内部碎片不是和页式一样少

# 虚拟内存管理

可以让作业部分装入就可以运行的技术

| 特征       | 描述                                         |
| ---------- | -------------------------------------------- |
| 部分装入   | 启动程序，程序一部分装入内存                 |
| 请求调入   | 当信息不在内存时，有操作系统将需要的部分调入 |
| 置换功能   | 将暂时不使用的调入外存                       |
| 虚拟存储器 | 逻辑上扩充存储器空间                         |

| 局部性原理 | 描述                                           |
| ---------- | ---------------------------------------------- |
| 时间局部   | 一次或下次访问都集中在一个较短的时期内         |
| 控件局部   | 访问的内容和邻近的内容都集中在一个较小的区域内 |

特点：离散性、多次性、对换性、虚拟性

软硬件支持

- 相当数量的外存
- 一定容量的内存
- 中断机构：当访问不在内存中，实行中断
- 地址变换机构：动态实现虚地址到实地址变换
- 相关数据结构：段表或页表

## 请求分页存储管理系统

### 管理方式

- 请求分页=基本分页+请求调页功能+页面置换功能

- 页表结构

  - 页号和物理块号
  - 状态位（存在位）：是否存在于主存
  - 访问字段一段时间内被访问的次数
  - 修改位：调入内存后是否被修改过

- 缺页中断与地址变换

  ![图片-缺页中断](queyezhongduan.jpg)

### 页面置换算法

- 最佳置换算法OPT：最先淘汰后面都不使用的
- 先进先出置换算法FIFO：
- 最近最少使用置换算法LRU：保留最近使用的
- 时钟置换算法CLOCK：从上一个被淘汰的页面开始遍历遇到访问位0就淘汰，将经过的访问位为1的都置为0
- 改进时钟置换算法CLOCK：同为0的页面优先淘汰未修改的。第一遍扫描不对经过的修改遇到访问位和过程位都为0的淘汰，若无第二遍对过程中访问位置0遇到访问位为0修改位为1淘汰，若无回到起始位重新执行1和2
- 最不常用置换算法LFU
- 页面缓冲算法PBA

### 页面分配策略

- 工作集论：让操作系统监视各进程的工作集，若内存有空，则再调一个进程进入内存。若超过，则选择一个进程对换到磁盘
- 页面分配策略
  - 固定分配局部置换：为每个进程分配固定的物理块
  - 可变分配全局置换：维护一个空闲物理块，每当进程缺页时，就分配给它，当空闲物理块不够时，就从任何进程中随机取出一页
  - 可变分配局部置换：为每个进程分配一定的物理块，当缺页中断时且无空闲物理块，只让进程换出自己的某个内存页，平凡缺页时就分配给它适当物理块，缺页率少时，适当减少物理块
- 页面调入策略
  - 请求调页策略：只有用到时才被调入内存
  - 预调页策略：预计不久之后会用到的调入内存
- 从何处调入
  - 系统拥有足够的兑换空间：从对换区全部调入
  - 系统缺少足够的对换空间：不被修改的从文件区调入，可能被修改的调到对换区调入
  - UNIX方式：与进程有关的都放入文件区，未运行的都在文件区，运行的且被换出的，由于是在对换区，下次仍从对换区调

### 抖动

- Belady移除：FIFO随物理块增加缺页率增加
- 抖动现性：刚被调出又要被调入
- 缺页率：所需页面调入内存的次数/访问次数

### 有效访问时间计算

- 访问的页在主存中,且在快表中EAT=a+t
- 访问的页在主存中,但不在快表中EAT=T+2*(a+t)，（T处理缺页中断时间）
- 访问的页不在主存中,更不在快表中EAT=T+2*(a+t)
- 加入缺页率和命中快表的概率：EAT=a+b*t+(1-b)*[t+f*(T+a+t)+(1-f)*(a+t)]，（f缺页率）

## 请求分段存储管理系统

与分页类似

## 内存管理方式比较

![图片-内存管理方式比较](neicunguanlibijiao.jpg)

## 内存管理地址的处理

![图片-内存管理地址的处理](dizhichuli.jpg)

# 参考文献

天勤操作系统

