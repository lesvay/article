---

title: 数据库范式
date: 2020-05-02 10:08:26
categories: 
    - 数据库
tags: 
    - 范式
---

# 概述

范式是为了消除重复数据减少冗余数据，从而让数据库内的数据更好的组织，让磁盘空间得到更有效利用的一种标准化标准。

目前数据库有六种范式，第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

低一级范式的关系模式通过模式分解可以转化为若干高一级范式的关系模式的集合，这个过程叫规范化。

![image-20200502101950598](Y:\hexoBlog\source\_posts\2020-05-02-sqlParadigm\guifanhua.png)

![关系](Y:\hexoBlog\source\_posts\2020-05-02-sqlParadigm\guanxi.png)

# 第一范式

数据库表中的每一列都是原子项，即属性不可分割。

这种根据实际项目的需求而定，比如地址可以继续划分为省市县，国外的姓名可以分为姓和名。

错误：

<table>
    <tr>
        <td rowspan="2">学号</td> 
        <td rowspan="2">姓名</td>
        <td  colspan="3">地址</td> 
   </tr>
    <tr>
        <td >省</td>
        <td>市</td >  
        <td>县</td > 
    </tr>
</table>

正确：

<table>
    <tr>
        <td >学号</td> 
        <td >姓名</td>
        <td >省</td>
        <td>市</td >  
        <td>县</td >
   </tr>
</table>

# 第二范式

在基于INF的基础上，消除主键部份依赖。每一个非主属性完全函数依赖于任何一个候选码，表中的字段必须完全依赖于全部主键而非部分主键。也就是每一行数据要有主键，要求其他字段都依赖于主键。

主键要求不可重复。

比如一个学生表则选取学号为主键，其他的信息都围绕着学好展开，存储的属性都是这个学号所代表的学生的相关信息，而不能存储其他属性。

错误：

| 学号 | 姓名 | 班级  | 课程           |
| ---- | ---- | ----- | -------------- |
| 1    | 小红 | cs1班 | 计算机网络     |
| 1    | 小红 | cs1班 | 计算机组成原理 |
| 2    | 小明 | cs1班 | 操作系统       |
| 3    | 小强 | cs2班 | 计算机网络     |
| 3    | 小强 | cs2班 | 操作系统       |

这时在INF中会产生以下问题：

+ 插入异常：当上述学生未选课时，选课信息为空，这时插入信息异常。
+ 删除异常：当小明想要退选操作系统课时，由于小明只有一条信息，这会导致小明的其他重要信息也会被删除。
+ 修改复杂：小红想要改名字，这时就需要修改两条数据。

正确：

| 学号 | 姓名 | 班级  |
| ---- | ---- | ----- |
| 1    | 小红 | cs1班 |
| 2    | 小明 | cs1班 |
| 3    | 小强 | cs2班 |

| 学号 | 课程           |
| ---- |-------------- |
| 1    |计算机网络     |
| 1    |计算机组成原理 |
| 2    |操作系统       |
| 3    |计算机网络     |
| 3    |操作系统       |
# 第三范式

在基于2NF的基础上，消除非主键传递依赖。非主键外的所有字段必须互不依赖，即所有非主属性对任何候选关键字都不存在传递依赖。

错误：

<table>
    <tr>
        <td >学号</td> 
        <td >姓名</td>
        <td >所在系</td>
        <td>系主任</td >  
   </tr>
</table>

在该表中，虽然姓名、所在系、系主任都是针对学号唯一的存在，但是所在系和系主任是传递关系，当有多个学生同在一个系时，会导致，系主任这个信息出现冗余，而且当系主任发生变更时，数据操作十分复杂。

正确：

<table>
    <tr>
        <td >学号</td> 
        <td >姓名</td>
        <td >所在系</td>
   </tr>
</table>

<table>
    <tr>
        <td >系名</td>
        <td >系主任</td>
   </tr>
</table>

# 巴斯-科德范式

基于3NF的基础上，每个表中只有一个候选键。

+ 所有非主属性对每一个码都是完全函数依赖。
+ 所有主属性对每一个不包含它的码也是完全函数依赖。
+ 没有任何属性完全函数依赖于非码的任何一组属性。

错误：

<table>
    <tr>
        <td >仓库ID</td> 
        <td >管理员ID</td>
        <td >存储物品ID</td>
        <td>数量</td >  
   </tr>
</table>

(仓库ID, 存储物品ID) →(管理员ID, 数量) 

(管理员ID, 存储物品ID) → (仓库ID, 数量) 

所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。

但是，由于存在如下决定关系：

(仓库ID) → (管理员ID) 

(管理员ID) → (仓库ID) 

即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。

正确：

<table>
    <tr>
        <td >仓库ID</td> 
        <td >管理员ID</td>
   </tr>
</table>

<table>
    <tr>
        <td >仓库ID</td> 
        <td >存储物品ID</td>
        <td>数量</td >  
   </tr>
</table>

# 第四范式

基于BC范式的基础上，不存在多值依赖导致的异常。即把同一表内的多对多关系删除。

错误：

比如：对于高数课，学校准备更换一本新的美版高数教材，但是还没有确定是由哪个老师教。

| Course | Teacher | Book       |
| ------ | ------- | ---------- |
| 英语   | Bill    | 人教版英语 |
| 英语   | Bill    | 美版英语   |
| 英语   | Jay     | 美版英语   |
| 高数   | William | 人教版高数 |
| 高数   | Dave？  | 美版高数   |

正确：

| Course | Teacher |
| ------ | ------- |
| 英语   | Bill    |
| 英语   | Jay     |
| 高数   | William |
| 高数   | Dave    |

| Course | Book       |
| ------ | ---------- |
| 英语   | 人教版英语 |
| 英语   | 美版英语   |
| 高数   | 人教版高数 |
| 高数   | 美版高数   |

# 第五范式

第四范式处理的是相互独立的多值情况，第五范式处理的是相互依赖的多值情况。

错误：

<table>
    <tr>
        <td >销售人员</td> 
        <td >供应商</td>
        <td>产品</td >  
   </tr>
</table>

正确：

<table>
    <tr>
        <td >销售人员</td> 
        <td >供应商</td>
   </tr>
</table>

<table>
    <tr>
        <td >销售人员</td> 
        <td>产品</td >  
   </tr>
</table>

<table>
    <tr>
        <td >供应商</td>
        <td>产品</td >  
   </tr>
</table>
# 码

码：表中可以唯一确定一个元组的某个属性（或者属性组），是整个实体集的性质。

超码：一个或多个属性的集合，这些属性可以让我们在一个实体集中唯一地表示一个实体。如果K是一个超码，那么所有包含K的集合也是超码。

候选码：从超码中选出来的，自然的候选码也是一个或多个属性的集合。候选码是最小的超码，它的任意真子集都不能成为超码。

主码：从候选码中挑一个出来做老大，它就叫主码，用来在同一实体集中区分不同实体的候选码。

主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。

非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。

# 依赖

对于关系R的两个属性集合XYZ，其中有X'为X的真子集。

部分函数依赖：存在X->Y，存在X'->Y，则X决定Y，Y依赖于X

举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。

完全函数依赖：存在X->Y，任意X'!->Y，则Y依赖于X

举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.

传递函数依赖：存在X->Y且Y!->X且Y->Z，则Z依赖于X

举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A

平凡函数依赖：Y是X的子集时，X->Y

非平凡函数依赖：Y不是X的子集时，X->Y

# 公理系统

## 推论规则

自反律：若Y为X的子集，XY为U的子集，则X->Y

增广律：若X->Y，且Z为U的子集，则XZ->YZ

传递律：若X->Y及Y->Z，则X->Z

## 推理规则

合并规则：X->Y，X->Z，X->YZ

伪传递规则：X->Y，WY->Z，XW->Z

分解规则：X->Y及Z为Y的子集，X->Z

## 最小依赖集

定义6.15  如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集。亦称为最小依赖集或最小覆盖。 
(1) F中任一函数依赖的右部仅含有一个属性。 
(2) F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。 
(3) F中不存在这样的函数依赖X→A， X有真子集Z使得F-{X→A}∪{Z→A}与F等价。