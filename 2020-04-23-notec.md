---
title: c语言笔记
date: 2020-04-23 14:38:03
categories: 
    - 编程语言
tags: 
    - c
---

# c语言中的数据类型

* 基本类型：不可以再分解

  * 整型
  * 字符型
  * 实型（浮点型）
    * 单精度型
    * 双精度型
  * 枚举类型

* 构造类型：可分解

  * 数组类型
  * 结构体类型
  * 共用体类型

* 指针类型

* 空类型:void，调用后不需要向调用者返回函数值

# 常量与进制

#define 定义常量，即宏定义

十进制不能有前缀0

八进制要有前缀0

十六进制要有前缀0X或0x

| 数据类型       | 32位字节数 | 64位字节数 | 取值范围                 |
| -------------- | ---------- | ---------- | ------------------------ |
| bool           | 1          | 1          | true false               |
| char           | 1          | 1          | -128,127                 |
| unsigned char  | 1          | 1          | 0,255                    |
| short          | 2          | 2          | -32768,32767             |
| unsigned short | 2          | 2          | 0,65535                  |
| int            | 4          | 4          | -2147483648,2147483647   |
| unsigned int   | 4          | 4          | 0,4294967295             |
| float          | 4          | 4          | -2^128,2^128;精度6,7     |
| double         | 8          | 8          | -2^1024,2^1024;精度15,16 |
| long double    | 8          | 8          | -2^1024,2^1024;精度15,16 |
| long long      | 8          | 8          | -2^64,2^64-1             |
| long           | 4          | 8          | /                        |
| unsigned long  | 4          | 8          | /                        |
| *              | 4          | 8          | /                        |

长整型 long，long long等，使用时在后面添加L或l

无符号unsigned，使用时在后面添加U或u

实数型又称浮点数型。十进制表示形式带小数点或后面加F或f，指数形式用E或e表示，如2.1E5（2.1*10^5）

# 浮点数的表示

浮点数通常被表示为：

N=M×R^E

比如： 12.345=1.2345×10^1
M(Mantissa)被称为浮点数的**尾数** 。

R(Radix)被称为阶码的**基数**，一般规定R为2、8或16，是一个确定的常数，不需要在浮点数中明确表示出来。

E(Exponent)被称为阶的**阶码** 。

表示浮点数：

​	一是要给出尾数M的值，通常用定点小数形式表示，它决定了	浮点数的表示精度，即可以给出的有效数字的位数。

​	二是要给出阶码，通常用定点整数形式表示，它指出的是小数	点在数据中的位置，决定了浮点数的表示范围。因此，在计算	机中,浮点数通常被表示成如下格式:（假定为32位浮点数，基为	2，其中最高位为符号位）

![浮点数](Y:\hexoBlog\source\_posts\2020-04-23-notec\fudianshu.jpg)

**规格化处理**

为了提高数据的表示精度同时保证数据表示的唯一性，需要对浮点数做规格化处理。

在计算机内，对非0值的浮点数，要求尾数的绝对值必须大于基数的倒数，即|M|≥1/R。

即要求尾数域的最高有效位应为1,称满足这种表示要求的浮点数为规格化表示：把不满足这一表示要求的尾数，变成满足这一要求的尾数的操作过程，叫作浮点数的规格化处理，通过尾数移位和修改阶码实现。

比如，二进制原码的规格化数的表现形式：(0正1负)

正数 0.1xxxxxx

负数 1.1xxxxxx

**浮点数的加减法运算**

浮点数的加法非常简单，只需要记住下面的这几个步骤就能够准确的运算：

```javascript
1）对阶，使得两数的小数点位置对齐。
2）尾数求和，将对阶后的两个尾数按照定点的加减法运算规则计算。
3）规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化
4）舍入，为提高精度，要考虑尾数右移时候丢失的数值位
5）溢出判断，判断计算结果是否存在溢出
```

**浮点数的乘除法运算**

浮点数的乘除法运算其实也是基于加减运算的。  运算步骤如下：

```javascript
1)阶码相加减:按照定点整数的加减法运算方法对两个浮点数的阶码进行加减运算。

2)尾数相乘或相除:按照定点小数的阵列乘除法运算方法对两个浮点数的尾数进行乘除运算。为了保证尾数相除时商的正确性，必须保证被除数尾数的绝对值一定小于除数尾数的绝对值。若被除数尾数的绝对值大于除数尾数的绝对值，需对被除数进行调整，即被除数的尾数每右移1位，阶码加1，直到被除数尾数的绝对值小于除数尾数的绝对值。

3)结果规格化并进行舍入处理:浮点数乘除运算结果的规格化和舍入处理与浮点数加减运算结果的规格化和舍入处理方法相同。并且在浮点数乘除运算的结果中，由于乘积和商的绝对值一定小于1，因此在浮点乘除运算结果进行规格化处理时只存在向左规格化，不可能出现向右规格化。

4)判断溢出:浮点数乘除运算结果的尾数不可能发生溢出，而浮点数运算结果的溢出则根据运算结果中浮点数的阶码来确定，溢出的判定和处理方法与浮点加减运算完全相同。
```

# 补码反码和原码

机器数：一个数在计算机中的二进制表示形式。

真值：带符号位的机器数对应的真正数值称为真值。

有符号的，第一位表示符号位1为-，0为+。

**原码**

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

> [+1]原 = 0000 0001
>
> [-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

> [1111 1111 , 0111 1111]

即

> [-127 , 127]

**反码**

反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

> [+1] = [00000001]原 = [00000001]反
>
> [-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

**补码**

补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

> [+1] = [00000001]原 = [00000001]反 = [00000001]补
>
> [-1] = [10000001]原 = [11111110]反 = [11111111]补

**补码反码的由来**

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

反码的出现解决了计算机加减运算时，减法运算使用正数+负数

补码的出现解决了计算机反码运算时出现的-0情况

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

> 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

> (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

# 混合运算

1) 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。

 2) 转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。

 3) 所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。

 4) char型和short型参与运算时，必须先转换成int型。

 5) 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入。 

![image-20200423173721134](Y:\hexoBlog\source\_posts\2020-04-23-notec\blzhuanhuan.png)

强制转换或自动转换时只是暂时的，其他式子仍按原来类型。

int a=b=c=5非法

int a,b,c;a=b=c=5合法

# printf

| 格式字符 | 意义                                         |
| -------- | -------------------------------------------- |
| d        | 以十进制形式输出带符号整数（负数前缀-）      |
| u        | 以十进制形式输出无符号整数                   |
| o        | 以八进制形式输出无符号整数（不输出前缀0）    |
| x,X      | 以十六进制形式输出无符号整数（不输出前缀0x） |
| f        | 以小数形式输出单、双精度实数                 |
| e,E      | 以指数形式输出单、双精度实数                 |
| g,G      | 以%f或%e中较短的输出宽度输出单、双精度实数   |
| c        | 输出单个字符                                 |
| s        | 输出字符串                                   |

输出最小宽度：%后跟着的十进制数字表示位数，超过原来的补空格或0，小于原来的按照原来输出。

精度：.后跟着的十进制数字，如果是数字则表示小数位数，如果是字符则表示字符个数。

长度：h按照短整型量输出、l按照长整型量输出。

printf自减自加从右往左计算。

# scanf

| 格式字符 | 意义                          |
| -------- | ----------------------------- |
| d        | 十进制形式整数                |
| u        | 无符号十进制整数              |
| o        | 八进制整数                    |
| x,       | 十六进制整数                  |
| f,e      | 实型数 （小数形式或指数形式） |
| c        | 输出单个字符                  |
| s        | 输出字符串                    |

%*d，星号表示跳过该输入

scanf("%d %*d %d",&a,&b);

宽度：%后面的十进制整数，制定输入的宽度

scanf("%4d%4d",&a,&b)；输入：123456789 将把 1234 赋予 a，而把 5678 赋予 b，9被截掉。

没有精度控制

ld表示长整型，hd表示短整型

空格也算输入的字符

要与格式控制串中的格式保持一致，如“%c %c”则输入a b，“%c%c”则输入ab，“%c,%c”则输入a,b

# 语句

if(a=b)==>把b的值给a后，判断a的真假

else与最近的一个if配对

goto语句：

loop:if(i<10){
		printf("%d\n",i);
		i++;
		goto loop;
	}

从键盘中输入数据：while(getchar()!='\n')

for循环执行过程

​	1) 先求解表达式 1。 

​	2) 求解表达式 2，若其值为真（非 0），则执行 for 语句中指定	的内嵌语句，然后执行下面第 3）步；若其 值为假（0），则 	结束循环，转到第 5）步。 

​	3) 求解表达式 3。 

​	4) 转回上面第 2）步继续执行。 

​	5) 循环结束，执行 for 语句下面的一个语句。 

二维数组未赋值的元素取0，int a[3[3={{1},{2},{3}}; 

1 0 0

2 0 0

3 0 0

 int a[[3={1,2,3,4,5,6,7,8,9};

字符数组得输入输出：

 char st[15];

scanf("%s",st);（不能加空格输入） 

printf("%s\n",st);（直接输出字符串时可识别转义字符） 

gets(st);（ 以回车结束，可以输入空格）

puts(st);（直接输出字符串时可识别转义字符） 

strcat (字符数组名 1，字符数组名 2)；把2中的字符串连接到1 中字符串的后面，并删去1中的“\0”，返回值是 1 的首地址。 

 strcpy (字符数组名 1，字符数组名 2) ；把 2 中的字符串拷贝到 1 中，“\0”也一同拷贝，相当于字符串赋值。 

strcmp(字符数组名 1，字符数组名 2)；相等为0，1大大于01小小于0。 

strlen(字符数组名)；返回字符串实际长度，不加'\0'

# 函数

不能嵌套定义

调用1：diaoyong(int a[5]){} main(){int a[5];diaoyong(a)}，两个a的长度最好一致，虽然可以编译通过，但是无意义

调用2：diaoyong(int a[]，int n){} main(){int a[5];diaoyong(a,5)}，两个a的长度最好一致，虽然可以编译通过，但是无意义

多维调用：int MA(int a[[10]) or int MA(int a[3[10])

在全局定义过的变量，局部也可以再次定义

# 存储

用户存储空间

​	①程序区

​	②静态存储区

​	③动态存储器

如果不声明static，则都是动态的分配存储空间auto，auto可以省略不写auto int b。

静态分配存储空间整个运行期间都不释放，静态局部变量编译时只赋一次初值，如果不赋值则编译时自动初值为0或空字符。

动态分配存储空间函数调用结束后即释放

register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。

​	1) 只有局部自动变量和形式参数可以作为寄存器变量；

​	2) 一个计算机系统中的寄存器数目有限，不能定义任意多个寄	存器变量；

​	 3) 局部静态变量不能定义为寄存器变量。

extern声明合法使用外部变量：main() {extern A,B;} int A=13,B=-8; 

# 宏定义

 #define M y*y，宏定义可以定义变量

 宏定义作用域，结束使用#undef： #define P 3 main(){P} #undef P

若宏用引号括起来，如“M”，则就是字符串不做代换

宏可以用来表示数据类型，#define INT int 

​	注意区分#define PIN1 int * ：int (*a),b;

​					#define PIN1 （int * ）:(int*) a,b

带参宏定义：#define MAX(a,b) (a>b)?a:b 

宏定义只是字符串的替换

# 条件编译

#ifdef  标识符   或者 #ifndef  标识符    或者 #if 常量表达式 

程序段 1 

#else   程序段 2 //可省略

#endif

它的功能是，如果标识符已被 #define 命令定义或没有被定义过则对程序段 1 进行编译；否则对程序段 2 进行编译。如果没有程序段 2则#else 省略。

常量表达式为真则实行，为假执行else

# 指针

变量的指针就是变量的地址。

存放变量地址的变量是指针变量

int *p=&a; 

 int *p; p=&a; 

指针不可以随便赋值。

指针未赋值时表示任意值，不可以使用，否则会造成意外错误。

指针赋0值时，不指向具体变量，可以使用，表示空指针。

数组指针a[n],中a[i]==>✳(a+i)==>✳(p+i)，其中p可以p++，a是地址常量不可以a++

++和✳同优先级，✳p++==>✳(p++)，是自右而左结合

f(int x[],int n)<==>f(int *x,int n)

多维数组

（a+i）表示多维数组第i行地址

a+1==*(a+1)==a[1]==&a[1]==&a[1[0]

✳(a[1]+1)==✳(✳(a+1)+1)==a[1[1]

**字符串**

printf（“%s”，字符串的首地址）；

字符串指针可以代替printf格式串

char ✳PF;   

PF="%d,%d,%d,%d,%d\n";   

printf(PF,a,*a,a[0],&a[0],&a[0[0]); 

‘\0’ASCII==0

字符串指针变量可以一次性赋值，而字符数组只能一个一个赋值

char *ps="C Language"<==> char *ps; ps="C Language"; 

static char st[]={"C Language"}; <!!==>char st[20];st={"C Language"}; 

数组指针

	printf("%d,",a);//6618608  
	printf("%d,",*a); //*a==a[0]     6618608
	printf("%d,",a[0]); //6618608     
	printf("%d,",&a[0]);  //6618608  
	printf("%d\n",&a[0][0]);  //6618608  
	printf("%d\n",&a[0][1]);  //6618612 
	
	printf("%d,",a[1]+1);   //6618628  
	printf("%d\n",*(a+1)+1);   //6618628 
	
	printf("%d,%d\n",*(a[1]+1),*(*(a+1)+1)); //a[1][1] 5,5
函数指针变量(指向函数的指针)

int(✳pmax)(); int max(int a,int b); ==> pmax=max; ==>z=(✳pmax)(x,y); 

main(int argc,char *argv)，接收命令行的参数，第一个表示个数，第二个存储参数是字符串指针数组，存放每一个命令字符串的首地址

| 定义 | 含义                          |
| -------- | ----------------------------- |
|int i;| 定义整型变量 i |
|int *p; |p 为指向整型数据的指针变量|
|int a[n];| 定义整型数组 a，它有 n 个元素 |
|int *p[n];| 定义指针数组 p，它由 n 个指向整型数据的指针元素组成 |
|int (*p)[n];| p 为指向含 n 个元素的一维数组的指针变量 |
|int f();| f 为带回整型函数值的函数 |
|int *p();| p 为带回一个指针的函数，该指针指向整型数据 |
|int (*p)();| p 为指向函数的指针，该函数返回一个整型值 |
|int **p;| P 是一个指针变量，它指向一个指向整型数据的指针变量 |

**指针赋值**

p=&a;        (将变量 a 的地址赋给 p) 

p=array;      (将数组 array 的首地址赋给 p) 

p=&array[i];   (将数组 array 第 i 个元素的地址赋给 p) 

p=max;       (max 为已定义的函数，将 max 的入口地址赋给 p) 

p1=p2;        (p1 和 p2 都是指针变量，将 p2 的值赋给 p1) 

ANSI 新标准增加了一种“void”指针类型，即可以定义一个指针变量，但不指定它是指向 哪一种类型数据

**结构体**

```
  struct stu{       
      int num;       
      char *name;       
      char sex;       
      float score;     
  }xiaohong={102,"Zhang ping",'M',78.5}
```

结构体指针

结构变量.成员名

 (*结构指针变量).成员名

结构指针变量->成员名 

**动态存储分配**

(类型说明符*)malloc(size)，分配长度为size的空间

(类型说明符*)calloc(n,size)，分配n块长度为size的空间

free(void*ptr); 释放空间

**枚举**

enum 枚举名{ 枚举值表 }; 

enum weekday { sun,mon,tue,wed,thu,fri,sat } a,b,c;

正确：a=sum; b=mon; a=(enum weekday)2;

错误：a=2; b=1;

a=sum；a++；此时a==mon

**类型**

typedef 原类型名  新类型名

# 位运算

| 定义 | 含义                          |
| -------- | ----------------------------- |
|&          |按位与     |
|\|          |按位或|
|^         | 按位异或    |
|~          |取反|
|<<n |左移n位，高位丢弃，低位补0|
|\>>n |右移n位，高位补0，低位丢弃。有符号数为正高位补0，为负低位补1|

**位域**

是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。

struct 位域结构名 { 

​	位域列表（形式：类型说明符 位域名：位域长度 ） 

​	int b:3

​	int c:2 //位域不能超过8

}; 

unsigned :0        空域，表示后面的从下一个单元存放

 int  :2  填充作用

使用： 位域变量名.位域名

# 文件

普通文件：（驻留在磁盘或其他外部介质上的一个有序数据集）程序文件（源文件、目标文件、可执行文件）、数据文件（输入输出数据）

设备文件：显示器、打印机、键盘等。输入输出类比于对磁盘的读写。通常把显示器定义为标准输出文件，printf、putchar

ASCII码文件：占4个字节

二进制文件：占2个字节，看成字符流按照字节处理

**文件指针**指向一个文件的指针：FILE *指针变量标识符

| 文件使用方式 | 意义                                               |
| ------------ | -------------------------------------------------- |
| “rt”         | 只读打开一个文本文件，只允许读数据                 |
| “wt”         | 只写打开或建立一个文本文件，只允许写数据           |
| “at”         | 追加打开一个文本文件，并在文件末尾写数据           |
| “rb”         | 只读打开一个二进制文件，只允许读数据               |
| “wb”         | 只写打开或建立一个二进制文件，只允许写数据         |
| “ab”         | 追加打开一个二进制文件，并在文件末尾写数据         |
| “rt+”        | 读写打开一个文本文件，允许读和写                   |
| “wt+”        | 读写打开或建立一个文本文件，允许读写               |
| “at+”        | 读写打开一个文本文件，允许读，或在文件末追加数据   |
| “rb+”        | 读写打开一个二进制文件，允许读和写                 |
| “wb+”        | 读写打开或建立一个二进制文件，允许读和写           |
| “ab+”        | 读写打开一个二进制文件，允许读，或在文件末追加数据 |

对于文件使用方式有以下几点说明： 

1) 文件使用方式由 r,w,a,t,b,+六个字符拼成，各字符的含义是：     	r(read):读 

​	w(write):写     

​	a(append):追加     

​	t(text):文本文件，可省略不写     

​	b(banary):二进制文件 

​	+:读和写 

2) 凡用“r”打开一个文件时，该文件必须已经存在，且只能从该文件读出。 

3) 用“w”打开的文件只能向该文件写入。若打开的文件不存在，则以指定的文件名建立 该文件，若打开的文件已经存在，则将该文件删去，重建一个新文件。 

4) 若要向一个已存在的文件追加新的信息，只能用“a”方式打开文件。但此时该文件必 须是存在的，否则将会出错。 5) 在打开一个文件时，如果出错，fopen 将返回一个空指针值 NULL。在程序中可以用这一 信息来判别是否完成打开文件的工作，并作相应的处理。因此常用以下程序段打开文件： if((fp=fopen("c:\\hzk16","rb")==NULL){          

 	printf("\nerror on open c:\\hzk16 file!");           

​	getch();   //等待用户敲任一键程序继续执行        

​	exit(1); 

} 

7) 把一个文本文件读入内存时，要将 ASCII 码转换成二进制码，而把文件以文本方式写入 磁盘时，也要把二进制码转换成 ASCII 码，因此文本文件的读写要花费较多的转换时间。 对二进制文件的读写不存在这种转换。 

8) 标准输入文件(键盘)，标准输出文件(显示器)，标准出错输出(出错信息)是由系统打开 的，可直接使用

打开文件：文件指针名=fopen(文件名,使用文件方式);

关闭文件：fclose(文件指针)；

将位置指针移到文件首：rewind(文件指针); 

移动文件指针：  fseek(文件指针,位移量,起始点); （起始点：文件首 SEEK_SET 0；当前位置 SEEK_CUR 1；文件末尾 SEEK_END 2 ）

文件读写：fread(读存储指针,sizeof(一次读取的大小),移动次数,文件指针);

判断是否处于结束位置：feof(文件指针);是1，否0

出错监测： ferror(文件指针); 是1否0

清除出错标志和结束标志：clearerr(文件指针);

```c
#include<stdio.h> 
struct stu {   
    char name[10];   
    int num;   
    int age;   
    char addr[15]; 
}boy,*qq; 
main() {   
    FILE *fp;  
    char ch; 
    int i=1;   
    qq=&boy;   
    if((fp=fopen("stu_list","rb"))==NULL){
        printf("Cannot open file strike any key exit!");   
        getch();     
        exit(1);   
    }  
    rewind(fp);   
    fseek(fp,i*sizeof(struct stu),0);
    fread(qq,sizeof(struct stu),1,fp);
    printf("\n\nname\tnumber      age      addr\n");   
    printf("%s\t%5d  %7d      %s\n",qq->name,qq->num,qq->age,qq->addr); 
} 
```

| 文件读写（stdio.h） |         |                                        |                                                              |
| ------------------- | ------- | -------------------------------------- | ------------------------------------------------------------ |
| 字符读写函数        | fgetc   | 字符变量=fgetc(文件指针);              | 读取的文件必须是以读或读写方式打开的，文件内部指针会移动，可以做多次读写 |
| 字符读写函数        | fputc   | fputc(字符量，文件指针);               | 用写、读写、追加方式打开。写入成功则返回写入的字符，否则返回一个 EOF |
| 字符串读写函数      | fgets   | fgets(字符数组名,n,文件指针);          | 从文件中读出的字符串不超过 n-1 个字符。                      |
| 字符串读写函数      | fputs   | fputs(字符串,文件指针);                |                                                              |
| 数据块读写函数      | freed   | fread(buffer,size,count,fp);           | buffer  是一个指针，在 fread 函数中，它表示存放输入数据的首地址。在 fwrite 函 数中，它表示存放输出数据的首地址。     size   表示数据块的字节数。     count  表示要读写的数据块块数。     fp     表示文件指针 |
| 数据块读写函数      | fwrite  | fwrite(buffer,size,count,fp);          |                                                              |
| 格式化读写函数      | fscanf  | fscanf(文件指针,格式字符串,输入表列);  |                                                              |
| 格式化读写函数      | fprintf | fprintf(文件指针,格式字符串,输出表列); |                                                              |

