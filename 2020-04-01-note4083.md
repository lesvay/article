---
title: 408刷题笔记3
date: 2020-04-01 08:37:28
categories: 
    - 刷题笔记
tags: 
    - 408
---

# 计算机网络

## 通信基础

信道不等于电路，一条可通信的电路可能包含多个信道

调制：数字->模拟

解调：模拟->数字

模拟：频带传输

数字：基带传输

| 方式                 |                        |
| -------------------- | ---------------------- |
| 模拟信号传输模拟数据 |                        |
| 模拟信号传输数字数据 | QAM                    |
| 数字信号传输模拟数据 | 脉冲编码调制PCM        |
| 数字信号传输数字数据 | 曼彻斯特、差分曼彻斯特 |

波特率（信号每秒变化的次数）=比特率/每码元含的比特数，即（log2 n，n为码元的有效值，此处为2）

数据率=波特率/n，n表示一位数据需要几个电平表示，此处为2，曼彻斯特为4，4B/5B为4个需要5个，为4/5

每码元所含比特数=传输速率/波特率

离散值的个数=2^每码元所含比特数

奈奎斯特：最大传输速率=2Wlog2V b/s,W表示带宽，采样频率、Baud=2W，V表示离散值个数

香农：Wlog2（1+S/N） b/s，S信道所传输信号的平均功率，N为信道高噪声功率，S/N为信噪比。其中dB=10log10（S/N）

奈奎斯特与香农两者相比取小的值

码元传输速率（码元速率、波形速率）：单位时间内数字通信系统所传输的码元（脉冲个数或信号变化的次数）个数

信息传输速率（信息速率、比特率）：单位时间内数字通信系统所传输的二进制码元（比特数）个数

香农定理：影响信道最大传输速率的因素：信道的带宽和噪声比

并行传输：距离短、速度快，适合计算机内部

串行传输：距离长、速度慢

曼彻斯特编码将时钟信号与数据信号都包含着信号中，并可以传输给对方，中间采用向上向下跳变区分0和1。适合二进制信号传输。占用的频带宽度是原始基带宽带的两倍。

声音是模拟信号

报文大小不固定，交换需要较大的存储空间，接收存储转发的时间不固定，所以不能应用于实时通信环境，如语音视频

以太网采用的是分组交互

| 交换技术 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 分组交换 | 将报文分割，减小了传输时延。传输单位相比报文更小，有固定的长度。分为数据报（无连接）较可靠，虚电路（连接），虚电路包括永久性和临时性。一条线子可以有多条虚电路 |
| 报文交换 | 不固定且较长                                                 |
| 电路交换 | 面向连接，建立时有时延，传输时实时性，不提供差错检测功能     |

NRZ 低电平0，高电平1

NRZI与前一个一样0，不一样1

# 操作系统

## 进程与线程

进程映像是：PCB、程序段和数据的组合，其中PCB是进程存在的唯一标志

操作系统通过PCB对进程进行控制，PCB包含基本状态和优先权

线程是处理机调度的基本单位可以独立执行程序，但没有自己独立的地址空间，可以通过他们的共享存储空间进行通信。

进程之间的地址是私有的只能自己访问

进程重要的特性是动态性

封闭性：执行结果只取决于自身

进程有生命周期，不会一直存在于系统之中，会因为结束或异常而撤销。

多对一的模型中，一个线程被阻塞则该进程被阻塞

| C语言程序                  | 解释             |
| -------------------------- | ---------------- |
| 代码和赋值数据段（正文段） | 二进制代码和常量 |
| 数据堆段                   | 动态分配的存储区 |
| 数据栈段                   | 临时使用的变量   |

全局变量与用户代码有关，与PCB无关

进程自身决定从运行状态到阻塞状态

I/O操作导致阻塞

进程间通信有管道、消息传递、共享内存、文件映射、套接字

进程可以创建进程或线程、线程只能创建线程

管道是一个固定大小的缓冲区，通常为内存的一页

多任务是针对于操作系统

多线程是针对于程序

# 计算机组成原理

## 定点数的表示与运算

补码表示最后要+1

1表示负号

int 32位 short 16位，8位1个字节

有符号转无符号，原来的补码就是现在的原码

| 0的表示 | +     | -     |
| ------- | ----- | ----- |
| 原码    | 00000 | 10000 |
| 反码    | 00000 | 11111 |
| 补码    | 00000 | 00000 |
| 移码    | 10000 | 10000 |

若x为正数，则原码、反码、补码相同

若x为负数，补码变原码，符号位不变，数值位取反，末尾+1

无论x是正数还是符数[x]求[-x]即连同符合每位取反末尾+1

n+1位定点小数反码范围：-1+2^(-n)<=x<=1-2^(-n)

n+1位定点小数原码范围：-2^(n)+1<=x<=2^(n)-1

补码移位，正数左右都添0，负数右1左0

原码移位左右补0

同一个数的补码和移码表示，数值相同，符号位相反

不带进位的位循环左移最高位进入最低位和标志寄存器

模4补码具有模2补码的全部优点且更容易检查加减运算中的溢出问题，存储时只需要一个符号位，在ALU中完成加减运算需要把每个符号位都送至ALU的双符号位中。

双符号位，第一位表示结果正0负 1，第二位表示是否溢出

加减法溢出，符号位C0最高位进位C1，异或为1表示溢出

*2左移，/2右移

补码范围-128~127

原码乘法符号位与数值位分开运算

补码一位乘法，需要移动n位，进行n+1次加法运算.原来的n位，右移n+1位，符号位，共2n+1位。

原码一位乘法，移动与加法运算均为n

原码不恢复余数除法即加减交替法，仅当最后一步不够减时，才恢复一次余数